# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Apply CLR transformation to a correlation matrix
#'
#' Normalizes a correlation matrix using the Context Likelihood Ratio (CLR)
#' transformation (Faith et al. 2007). Computes row z-scores, clamps negatives
#' to zero, and combines row and column z-scores.
#'
#' @param cor_matrix Symmetric correlation matrix (n x n)
#' @param n_cores Number of OpenMP threads (default: 1)
#' @return CLR-transformed matrix (n x n), symmetric, non-negative
#'
#' @details
#' The CLR transformation:
#' \preformatted{
#' z_row(i,j) = (cor(i,j) - mean(row_i)) / sd(row_i)
#' z_col(i,j) = (cor(i,j) - mean(col_j)) / sd(col_j)
#' CLR(i,j) = sqrt(max(0, z_row)^2 + max(0, z_col)^2)
#' }
#'
#' This matches the original RComPlEx Rmd CLR implementation which uses
#' R's scale() function (column-wise z-scoring on the symmetric matrix,
#' equivalent to row-wise z-scoring due to symmetry).
#'
#' @keywords internal
apply_clr_to_cor_cpp <- function(cor_matrix, n_cores = 1L) {
    .Call(`_rcomplex_apply_clr_to_cor_cpp`, cor_matrix, n_cores)
}

#' Compute density threshold from a symmetric matrix
#'
#' Extracts the upper triangle (excluding diagonal) and finds the value at
#' the given density percentile using O(n) partial sort.
#'
#' @param mat Symmetric matrix (n x n)
#' @param density Fraction of top edges to keep (e.g., 0.03 for 3%)
#' @return The threshold value such that `density` fraction of upper triangle
#'   values are >= the threshold
#'
#' @keywords internal
density_threshold_cpp <- function(mat, density) {
    .Call(`_rcomplex_density_threshold_cpp`, mat, density)
}

#' Permutation-based HOG-level conservation test
#'
#' Tests each HOG for co-expression conservation using a gene-identity
#' permutation null with adaptive stopping (Besag & Clifford, 1991).
#'
#' @param net1 Co-expression network matrix for species 1 (n1 x n1)
#' @param net2 Co-expression network matrix for species 2 (n2 x n2)
#' @param thr1 Co-expression threshold for species 1
#' @param thr2 Co-expression threshold for species 2
#' @param ortho_sp1_idx 0-based net1 indices for full ortholog table
#' @param ortho_sp2_idx 0-based net2 indices for full ortholog table
#' @param hog_sp1_list List of integer vectors: unique 0-based sp1 indices per HOG
#' @param hog_sp2_list List of integer vectors: unique 0-based sp2 indices per HOG
#' @param test_greater If TRUE, test conservation (T >= T_obs); if FALSE, divergence
#' @param min_exceedances Besag-Clifford stopping parameter (default 50)
#' @param max_permutations Maximum permutations per HOG (default 10000)
#' @param n_cores Number of OpenMP threads (default 1)
#' @return DataFrame with T_obs, n_perm, n_exceed, p_value per HOG
#'
#' @keywords internal
hog_permutation_test_cpp <- function(net1, net2, thr1, thr2, ortho_sp1_idx, ortho_sp2_idx, hog_sp1_list, hog_sp2_list, test_greater, min_exceedances, max_permutations, n_cores) {
    .Call(`_rcomplex_hog_permutation_test_cpp`, net1, net2, thr1, thr2, ortho_sp1_idx, ortho_sp2_idx, hog_sp1_list, hog_sp2_list, test_greater, min_exceedances, max_permutations, n_cores)
}

#' Cached mutual rank transformation
#'
#' Transforms a correlation matrix using mutual rank normalization.
#'
#' @param sim Symmetric correlation/similarity matrix (n x n)
#' @param log_transform If FALSE (default), uses raw mutual rank with ascending
#'   ranks (original Rmd formula). If TRUE, applies Obayashi & Kinoshita (2009)
#'   log-normalized formula with descending ranks (values in 0 to 1 range).
#' @param n_cores Number of OpenMP threads (default: 1)
#' @return Mutual rank normalized matrix (n x n)
#'
#' @details
#' When `log_transform = TRUE`:
#' \deqn{S_{ij} = 1 - \log(\sqrt{R_{ij} \cdot R_{ji}}) / \log(n)}
#' where ranks are descending (highest correlation = rank 1).
#'
#' When `log_transform = FALSE`:
#' \deqn{MR_{ij} = \sqrt{R_{ij} \cdot R_{ji}}}
#' where ranks are ascending (lowest correlation = rank 1), matching the
#' original RComPlEx R Markdown formula.
#'
#' @keywords internal
mutual_rank_transform_cached_cpp <- function(sim, log_transform = FALSE, n_cores = 1L) {
    .Call(`_rcomplex_mutual_rank_transform_cached_cpp`, sim, log_transform, n_cores)
}

#' Compare co-expression neighborhoods across species (integer-indexed)
#'
#' For each ortholog pair, tests the overlap of co-expression neighborhoods
#' in both directions (sp1->sp2 and sp2->sp1) using hypergeometric tests.
#' All gene identifiers are 0-based integer indices (string mapping done in R).
#'
#' @param net1 Co-expression network for species 1 (n1 x n1 matrix)
#' @param net2 Co-expression network for species 2 (n2 x n2 matrix)
#' @param thr1 Co-expression threshold for species 1
#' @param thr2 Co-expression threshold for species 2
#' @param pair_sp1_idx 0-based index into net1 for each ortholog pair
#' @param pair_sp2_idx 0-based index into net2 for each ortholog pair
#' @param ortho_sp1_idx 0-based net1 indices for full ortholog table
#' @param ortho_sp2_idx 0-based net2 indices for full ortholog table
#' @param n_cores Number of OpenMP threads (default: 1)
#' @return DataFrame with comparison results for each ortholog pair
#'
#' @keywords internal
compare_neighborhoods_cpp <- function(net1, net2, thr1, thr2, pair_sp1_idx, pair_sp2_idx, ortho_sp1_idx, ortho_sp2_idx, n_cores = 1L) {
    .Call(`_rcomplex_compare_neighborhoods_cpp`, net1, net2, thr1, thr2, pair_sp1_idx, pair_sp2_idx, ortho_sp1_idx, ortho_sp2_idx, n_cores)
}

